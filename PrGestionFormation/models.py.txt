import uuid
from datetime import date

from Formation.models import BaseRoleModel
from django.apps import apps
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin, Permission, Group
from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import ValidationError
from django.core.validators import MinLengthValidator
from django.db import models


class CustomUserManager(BaseUserManager):
    def _create_user(self, matricule, password=None, **extra_fields):
        """
        Cr√©e et enregistre un utilisateur avec le matricule et mot de passe
        """
        if not matricule:
            raise ValueError('Le matricule est obligatoire')

        user = self.model(matricule=matricule, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, matricule, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', False)
        extra_fields.setdefault('is_superuser', False)
        return self._create_user(matricule, password, **extra_fields)

    def create_superuser(self, matricule, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('role', 'ADMIN')
        return self._create_user(matricule, password, **extra_fields)

class Genre(models.Model):
    code = models.CharField(max_length=10, unique=True)
    libelle = models.CharField(max_length=50)
    description = models.TextField(blank=True, null=True)
    est_par_defaut = models.BooleanField(default=False)

    def __str__(self):
        return self.libelle

    @classmethod
    def initialiser_genres(cls):
        # Liste des genres avec "Non pr√©cis√©" comme d√©faut
        genres = [
            {'code': 'F', 'libelle': 'Femme', 'description': 'Genre f√©minin', 'est_par_defaut': False},
            {'code': 'H', 'libelle': 'Homme', 'description': 'Genre masculin', 'est_par_defaut': False},
            {'code': 'ND', 'libelle': 'Non pr√©cis√©', 'description': 'Genre non d√©clar√©', 'est_par_defaut': True},
        ]

        for data in genres:
            cls.objects.get_or_create(code=data['code'], defaults=data)

    @classmethod
    def get_default_genre(cls):
        try:
            return cls.objects.get(est_par_defaut=True).id
        except:
            return None  # Retourne None si la table n'existe pas ou aucun d√©faut

    class Meta:
        verbose_name = "Genre"
        verbose_name_plural = "Genres"



class Utilisateur(AbstractBaseUser, PermissionsMixin,BaseRoleModel):
    print("\nInitialisation de la classe Utilisateur...")
    class Role(models.TextChoices):
        ADMIN = 'ADMIN', 'Administrateur Syst√®me'
        AGENT = 'AGENT', 'Agent administratif'
        ENSEIGNANT = 'ENSEIGNANT', 'Enseignant'
        ETUDIANT = 'ETUDIANT', '√âtudiant'
        PARENT = 'PARENT', 'Parent'

    # Champs d'authentification
    matricule = models.CharField(max_length=20, unique=True)
    email = models.EmailField(blank=True, null=True)
    telephone = models.CharField(max_length=20, blank=True, null=True)

    # Champs personnels
    first_name = models.CharField('first name', max_length=30, blank=True)
    last_name = models.CharField('last name', max_length=150, blank=True)
    role = models.CharField(max_length=20, choices=Role.choices)
    date_inscription = models.DateTimeField(auto_now_add=True)
    date_nais = models.DateField(default=date(1990, 1, 1))
    genre = models.ForeignKey(
        Genre,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        default=None,  # Temporairement √† None
        verbose_name="Genre"
    )

    doit_changer_mot_de_passe = models.BooleanField(default=True)
    # Champs requis pour AbstractBaseUser
    is_staff = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)

    objects = CustomUserManager()

    USERNAME_FIELD = 'matricule'
    REQUIRED_FIELDS = ['role']



    def __str__(self):
        return f"{self.matricule} ({self.get_full_name()})"

    @classmethod
    def create_admin_user(cls, matricule, password, **extra_fields):
        """M√©thode s√©curis√©e pour cr√©er un admin syst√®me"""
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('role', cls.Role.ADMIN)

        if extra_fields.get('role') != cls.Role.ADMIN:
            raise ValueError("Le r√¥le doit √™tre ADMIN pour un administrateur syst√®me")

        user = cls.objects.create_user(
            matricule=matricule,
            password=password,
            **extra_fields
        )
        return user

    def get_full_name(self):
        return f"{self.first_name} {self.last_name}".strip()

    def iget_full_name(self):
        return f"{self.last_name} {self.first_name}".strip()

    def get_initials(self):
        initials = ''
        if self.first_name:
            initials += self.first_name[0].upper()
        if self.last_name:
            initials += self.last_name[0].upper()
        return initials or '??'

    def get_role_display_name(self):
        """Retourne le nom d'affichage complet du r√¥le"""
        return self.get_role_display()

    # Ou sous forme de propri√©t√© pour un acc√®s plus naturel
    @property
    def role_display(self):
        """Retourne le nom d'affichage complet du r√¥le (propri√©t√©)"""
        return self.get_role_display()
    # Utilisateur/models.py
    def assign_role_permissions(self):
        """Attribue les permissions selon le type de profil"""
        print(f"\nD√©but assign_role_permissions() pour {self.matricule}")

        try:
            # R√©cup√®re la configuration des permissions pour ce r√¥le
            role = self.role
            print(f"Le role : {role}")
            role_perm = RolePermission.objects.get(role=role)
            print(f"Configuration trouv√©e: {role_perm}")

            # Nettoie les groupes existants
            self.groups.clear()
            print("Groupes existants nettoy√©s")

            # Ajoute au groupe correspondant
            self.groups.add(role_perm.groupe)
            print(f"Ajout√© au groupe: {role_perm.groupe.name}")

            # Pour les admins, on active les flags
            if self.role == self.Role.ADMIN:
                self.is_staff = True
                self.is_superuser = True
                print("D√©fini comme superutilisateur (admin)")

        except Exception as e:
            print(f"ERREUR dans assign_role_permissions: {str(e)}")
            raise

    def save(self, *args, **kwargs):
        """Sauvegarde avec gestion du matricule et des permissions"""
        print(f"\nSauvegarde Utilisateur {self.matricule or 'nouveau'}")

        # G√©n√©ration du matricule si vide
        if not self.matricule:
            prefix = {
                'ADMIN': 'ADM',
                'AGENT': 'AGT',
                'ENSEIGNANT': 'ENS',
                'ETUDIANT': 'ETU',
                'PARENT': 'PAR'
            }.get(self.role, 'USR')
            self.matricule = f"{prefix}-{uuid.uuid4().hex[:6].upper()}"
            print(f"Matricule g√©n√©r√©: {self.matricule}")

        super().save(*args, **kwargs)  # On sauvegarde normalement
        self.assign_role_permissions()  # Puis on assigne les permissions
        print("Utilisateur sauvegard√© avec permissions")


class FonctionAgent(models.Model):
    code = models.CharField(
        max_length=50,
        unique=True,
        validators=[MinLengthValidator(3)],
        help_text="Code unique de la fonction (ex: SECRETAIRE_ADMIN)"
    )
    nom = models.CharField(
        max_length=100,
        help_text="Nom complet de la fonction (ex: Secr√©taire administratif)"
    )
    description = models.TextField(
        help_text="Description d√©taill√©e du r√¥le et des missions"
    )
    responsabilites = models.JSONField(
        default=list,
        help_text="Liste des responsabilit√©s principales"
    )
    controles = models.JSONField(
        default=list,
        help_text="Liste des m√©canismes de contr√¥le associ√©s"
    )
    protocoles = models.JSONField(
        default=list,
        help_text="Liste des protocoles et proc√©dures sp√©cifiques"
    )
    role = models.CharField(
        max_length=20,
        choices=Utilisateur.Role.choices,
        default=Utilisateur.Role.AGENT,
        editable=False
    )

    # D√©finition des permissions disponibles structur√©es
    PERMISSIONS_DISPONIBLES = {
        'formation': {
            'view': 'Voir les formations',
            'add': 'Ajouter une formation',
            'change': 'Modifier une formation',
            'delete': 'Supprimer une formation'
        },
        'classe': {
            'view': 'Voir les classes',
            'add': 'Ajouter une classe',
            'change': 'Modifier une classe'
        },
        'utilisateur': {
            'view': 'Voir les utilisateurs'
        },
        'courrier': {
            'view': 'Voir le courrier',
            'add': 'Ajouter du courrier'
        },
        'dossier': {
            'view': 'Voir les dossiers',
            'change': 'Modifier les dossiers'
        }
    }

    permissions = models.ManyToManyField(
        Permission,
        blank=True,
        related_name='fonctions_agent',
        limit_choices_to={'codename__in': []},  # Initialis√© vide, rempli dans la m√©thode
        help_text="Permissions sp√©cifiques √† cette fonction"
    )

    @classmethod
    def get_allowed_permissions(cls):
        """Retourne la liste des noms de permissions autoris√©es"""
        return [
            f"{action}_{model}"
            for model, actions in cls.PERMISSIONS_DISPONIBLES.items()
            for action in actions.keys()
        ]

    class Meta:
        ordering = ['nom']
        verbose_name = "Fonction d'agent"
        verbose_name_plural = "Fonctions d'agents"

    def __str__(self):
        return self.nom

    @classmethod
    def get_permissions_choices(cls):
        """
        G√©n√®re dynamiquement les paires (codename, description)
        √† partir de votre structure existante
        """
        permissions = []
        for model, actions in cls.PERMISSIONS_DISPONIBLES.items():
            model_perms = []
            for action, description in actions.items():
                codename = f"{action}_{model}"
                model_perms.append((codename, {
                    'name': codename,
                    'description': description
                }))
                print(codame)
                print(description)
            permissions.append((model, model_perms))
        return permissions

    @classmethod
    def creer_permissions(cls):
        """Cr√©e les permissions en base si elles n'existent pas"""
        ContentType = apps.get_model('contenttypes', 'ContentType')
        Permission = apps.get_model('auth', 'Permission')
        created = []

        for model, actions in cls.PERMISSIONS_DISPONIBLES.items():
            try:
                content_type = ContentType.objects.get(
                    app_label='votre_app',  # √Ä adapter!
                    model=model
                )

                for action, name in actions.items():
                    codename = f"{action}_{model}"
                    perm, is_new = Permission.objects.get_or_create(
                        codename=codename,
                        content_type=content_type,
                        defaults={'name': name}
                    )
                    if is_new:
                        created.append(perm)

            except ContentType.DoesNotExist:
                print(f"Attention: ContentType pour {model} non trouv√©")
                continue

        return created

    def clean(self):
        Utilisateur = apps.get_model('Utilisateur', 'Utilisateur')
        if self.role != Utilisateur.Role.AGENT:
            raise ValidationError("Une fonction doit √™tre associ√©e au r√¥le AGENT.")

        # Validation suppl√©mentaire pour s'assurer que les permissions sont valides
        if self.pk:  # Only check if instance already exists
            valid_permissions = [
                f"{action}_{model}"
                for model, actions in self.PERMISSIONS_DISPONIBLES.items()
                for action in actions.keys()
            ]
            invalid_perms = self.permissions.exclude(codename__in=valid_permissions)
            if invalid_perms.exists():
                raise ValidationError(
                    f"Certaines permissions ne sont pas autoris√©es: {', '.join(invalid_perms.values_list('codename', flat=True))}"
                )

    def save(self, *args, **kwargs):
        self.clean()
        super().save(*args, **kwargs)

    @classmethod
    def initialiser_fonctions(cls):
        try:
            role_agent = Utilisateur.Role.AGENT
        except Role.DoesNotExist:
            raise Exception("Le r√¥le AGENT doit √™tre cr√©√© avant les fonctions")

        fonctions = [
            {
                'code': 'SECRETAIRE_ADMINISTRATIF',
                'nom': 'Secr√©taire administratif',
                'description': "Gestion centralis√©e du courrier et documents administratifs",
                'responsabilites': [
                    "Gestion du courrier entrant/sortant",
                    "Classement et archivage des documents",
                    "Accueil physique et t√©l√©phonique",
                    "Pr√©paration des dossiers pour r√©unions",
                    "Saisie des donn√©es administratives"
                ],
                'controles': [
                    "V√©rification quotidienne du bon acheminement du courrier",
                    "Audit mensuel des dossiers archiv√©s"
                ],
                'protocoles': [
                    "Proc√©dure de traitement du courrier confidentiel",
                    "Protocole de destruction des documents obsol√®tes"
                ]
            },
            {
                'code': 'CHARGE_INSCRIPTIONS',
                'nom': 'Charg√© des inscriptions',
                'description': "Gestion du processus complet d'inscription des √©tudiants",
                'responsabilites': [
                    "V√©rification des dossiers d'inscription",
                    "Enregistrement des nouveaux √©tudiants",
                    "Gestion des d√©rogations",
                    "Coordination avec le service financier",
                    "Mise √† jour des fichiers √©tudiants"
                ],
                'controles': [
                    "Contr√¥le al√©atoire de 10% des dossiers",
                    "V√©rification des pi√®ces justificatives"
                ],
                'protocoles': [
                    "Proc√©dure de validation des d√©rogations",
                    "Protocole RGPD pour les donn√©es personnelles"
                ]
            },
            {
                'code': 'GESTIONNAIRE_DOSSIERS',
                'nom': 'Gestionnaire des dossiers √©tudiants',
                'description': "Maintenance et mise √† jour des dossiers √©tudiants",
                'responsabilites': [
                    "Maintenance des dossiers √©tudiants",
                    "V√©rification des pi√®ces manquantes",
                    "Archivage num√©rique et physique",
                    "R√©ponse aux demandes d'acc√®s",
                    "Application des r√®gles RGPD"
                ],
                'controles': [
                    "V√©rification trimestrielle de l'exhaustivit√© des dossiers",
                    "Contr√¥le d'acc√®s aux documents sensibles"
                ],
                'protocoles': [
                    "Protocole de mise √† jour des dossiers",
                    "Proc√©dure de r√©ponse aux demandes l√©gales"
                ]
            },
            {
                'code': 'AGENT_SCOLARITE',
                'nom': 'Agent de scolarit√©',
                'description': "Gestion administrative des parcours √©tudiants",
                'responsabilites': [
                    "Suivi des inscriptions p√©dagogiques",
                    "Gestion des changements de fili√®re",
                    "√âdition des attestations",
                    "Coordination avec les d√©partements",
                    "Traitement des demandes sp√©ciales"
                ],
                'controles': [
                    "V√©rification des pr√©requis acad√©miques",
                    "Contr√¥le des droits d'inscription"
                ],
                'protocoles': [
                    "Proc√©dure de changement de parcours",
                    "Protocole d'√©dition des documents officiels"
                ]
            },
            {
                'code': 'RESPONSABLE_EMPLOI_TEMPS',
                'nom': 'Responsable des emplois du temps',
                'description': "Cr√©ation et gestion des plannings acad√©miques",
                'responsabilites': [
                    "√âlaboration des plannings",
                    "Gestion des salles et ressources",
                    "R√©solution des conflits d'horaire",
                    "Publication des calendriers",
                    "Coordination avec les enseignants"
                ],
                'controles': [
                    "V√©rification de l'ad√©quation salles/effectifs",
                    "Contr√¥le du respect des volumes horaires"
                ],
                'protocoles': [
                    "Protocole de modification des plannings",
                    "Proc√©dure d'urgence pour salles indisponibles"
                ]
            },
            {
                'code': 'AGENT_DISCIPLINE',
                'nom': 'Agent charg√© de la discipline',
                'description': "Application du r√®glement int√©rieur et suivi disciplinaire",
                'responsabilites': [
                    "Enregistrement des incidents",
                    "Application du r√®glement int√©rieur",
                    "Suivi des mesures disciplinaires",
                    "Communication avec les familles",
                    "Rapports mensuels"
                ],
                'controles': [
                    "V√©rification de la proportionnalit√© des sanctions",
                    "Contr√¥le du suivi des mesures"
                ],
                'protocoles': [
                    "Proc√©dure de traitement des incidents graves",
                    "Protocole de signalement aux autorit√©s comp√©tentes"
                ]
            },
            {
                'code': 'CHARGE_EXAMENS',
                'nom': 'Charg√© des examens et concours',
                'description': "Organisation logistique des √©valuations acad√©miques",
                'responsabilites': [
                    "Organisation des sessions d'examen",
                    "Gestion des sujets et copies",
                    "Coordination des surveillances",
                    "S√©curisation des √©preuves",
                    "Traitement des fraudes"
                ],
                'controles': [
                    "Double v√©rification des sujets",
                    "Contr√¥le d'identit√© strict en salle"
                ],
                'protocoles': [
                    "Protocole de s√©curisation des sujets",
                    "Proc√©dure de traitement des fraudes"
                ]
            },
            {
                'code': 'RESPONSABLE_BULLETINS',
                'nom': 'Responsable des bulletins et relev√©s de notes',
                'description': "Gestion et diffusion des r√©sultats acad√©miques",
                'responsabilites': [
                    "Saisie et v√©rification des notes",
                    "√âdition des relev√©s de notes",
                    "Gestion des r√©clamations",
                    "Archivage des r√©sultats",
                    "Calcul des moyennes"
                ],
                'controles': [
                    "Double contr√¥le des calculs de moyennes",
                    "V√©rification des validations p√©dagogiques"
                ],
                'protocoles': [
                    "Protocole de correction des erreurs",
                    "Proc√©dure de traitement des r√©clamations"
                ]
            },
            {
                'code': 'AGENT_ATTESTATIONS',
                'nom': 'Agent charg√© des attestations et dipl√¥mes',
                'description': "√âmission et gestion des documents officiels",
                'responsabilites': [
                    "√âmission des documents officiels",
                    "Gestion des demandes de duplicata",
                    "V√©rification des droits",
                    "Archivage s√©curis√©",
                    "Lutte contre la fraude"
                ],
                'controles': [
                    "V√©rification syst√©matique des droits",
                    "Contr√¥le qualit√© avant √©mission"
                ],
                'protocoles': [
                    "Proc√©dure d'√©mission des duplicata",
                    "Protocole anti-fraude des documents"
                ]
            },
            {
                'code': 'GESTIONNAIRE_COURRIER',
                'nom': 'Gestionnaire du courrier administratif',
                'description': "Gestion du flux de courrier institutionnel",
                'responsabilites': [
                    "Tri et distribution du courrier",
                    "Gestion des envois institutionnels",
                    "Tra√ßabilit√© des exp√©ditions",
                    "Num√©risation des documents",
                    "Classement chronologique"
                ],
                'controles': [
                    "Tra√ßabilit√© compl√®te des envois",
                    "V√©rification des accus√©s de r√©ception"
                ],
                'protocoles': [
                    "Protocole pour courrier confidentiel",
                    "Proc√©dure d'urgence pour courrier recommand√©"
                ]
            },
            {
                'code': 'SUIVI_ENSEIGNANTS',
                'nom': 'Responsable du suivi des enseignants',
                'description': "Gestion administrative des intervenants p√©dagogiques",
                'responsabilites': [
                    "Suivi des contrats enseignants",
                    "Gestion des services horaires",
                    "Interface avec les services RH"
                ],
                'controles': [
                    "V√©rification des qualifications",
                    "Contr√¥le du respect des volumes horaires"
                ],
                'protocoles': [
                    "Protocole de recrutement des vacataires",
                    "Proc√©dure de signalement des absences"
                ]
            },
            {
                'code': 'LIAISON_PEDAGOGIQUE',
                'nom': 'Agent de liaison p√©dagogique',
                'description': "Interface entre administration et corps enseignant",
                'responsabilites': [
                    "Transmission des informations p√©dagogiques",
                    "Remont√©e des besoins mat√©riels",
                    "Organisation des r√©unions p√©dagogiques"
                ],
                'controles': [
                    "Suivi des comptes-rendus de r√©union",
                    "V√©rification de la diffusion des informations"
                ],
                'protocoles': [
                    "Protocole de circulation de l'information",
                    "Proc√©dure d'urgence pour probl√®mes p√©dagogiques"
                ]
            },
            {
                'code': 'RESSOURCES_MATERIELLES',
                'nom': 'Agent de gestion des ressources mat√©rielles',
                'description': "Gestion du patrimoine mat√©riel p√©dagogique",
                'responsabilites': [
                    "Inventaire du mat√©riel",
                    "Gestion des pr√™ts",
                    "Organisation de la maintenance"
                ],
                'controles': [
                    "V√©rification trimestrielle des stocks",
                    "Contr√¥le des conditions de s√©curit√©"
                ],
                'protocoles': [
                    "Protocole de pr√™t de mat√©riel",
                    "Proc√©dure de signalement des dysfonctionnements"
                ]
            },
            {
                'code': 'CHARGE_CONVOCATIONS',
                'nom': 'Charg√© des convocations',
                'description': "Gestion des convocations officielles",
                'responsabilites': [
                    "√âdition des convocations",
                    "Gestion des envois",
                    "Suivi des confirmations"
                ],
                'controles': [
                    "V√©rification des listes de destinataires",
                    "Contr√¥le des accus√©s de r√©ception"
                ],
                'protocoles': [
                    "Protocole pour convocations urgentes",
                    "Proc√©dure de relance des absents"
                ]
            },
            {
                'code': 'BASE_DONNEES_ETUDIANTS',
                'nom': 'Responsable de la base de donn√©es √©tudiants',
                'description': "Gestion et s√©curisation des donn√©es √©tudiantes",
                'responsabilites': [
                    "Mise √† jour des donn√©es",
                    "Sauvegarde des informations",
                    "Gestion des acc√®s"
                ],
                'controles': [
                    "V√©rification quotidienne des sauvegardes",
                    "Audit semestriel des acc√®s"
                ],
                'protocoles': [
                    "Protocole RGPD pour donn√©es sensibles",
                    "Proc√©dure de r√©cup√©ration apr√®s incident"
                ]
            },
            {
                'code': 'AGENT_ACCUEIL',
                'nom': "Agent d'accueil et d'information",
                'description': "Premier contact avec l'institution",
                'responsabilites': [
                    "Accueil physique et t√©l√©phonique",
                    "Orientation des visiteurs",
                    "Gestion des demandes courantes"
                ],
                'controles': [
                    "Mesure de la satisfaction usagers",
                    "Suivi du temps d'attente"
                ],
                'protocoles': [
                    "Protocole d'accueil des personnes √† mobilit√© r√©duite",
                    "Proc√©dure pour situations d'urgence"
                ]
            },
            {
                'code': 'AGENT_COMPTABLE',
                'nom': 'Agent comptable',
                'description': "Gestion des aspects financiers √©tudiants",
                'responsabilites': [
                    "Encaissement des frais de scolarit√©",
                    "Gestion des √©ch√©anciers",
                    "Rapprochement bancaire"
                ],
                'controles': [
                    "V√©rification quotidienne des encaissements",
                    "Contr√¥le mensuel des impay√©s"
                ],
                'protocoles': [
                    "Protocole de traitement des paiements en retard",
                    "Proc√©dure de remboursement"
                ]
            }
        ]

        for data in fonctions:
            fonction, created = cls.objects.get_or_create(
                code=data['code'],
                defaults={
                    'nom': data['nom'],
                    'description': data['description'],
                    'responsabilites': data.get('responsabilites', []),
                    'controles': data.get('controles', []),
                    'protocoles': data.get('protocoles', [])
                }
            )
            if not created:
                fonction.nom = data['nom']
                fonction.description = data['description']
                fonction.save()




class AdminSysteme(BaseRoleModel):
    utilisateur = models.OneToOneField(
        Utilisateur,
        on_delete=models.CASCADE,
        primary_key = True,
        limit_choices_to = {'role': Utilisateur.Role.ADMIN, 'is_superuser': True}
    )


class AgentAdministration(BaseRoleModel):
    utilisateur = models.OneToOneField(
        Utilisateur,
        on_delete=models.CASCADE,
        primary_key=True,
        limit_choices_to={'role': 'AGENT'}
    )
    fonctions = models.ManyToManyField(FonctionAgent)  # Plus de unique_together ici

    def __str__(self):
        return f"{self.utilisateur} - {', '.join(f.nom for f in self.fonctions.all())}"

    def save(self, *args, **kwargs):
        if self.utilisateur.role != Utilisateur.Role.AGENT:
            self.utilisateur.role = Utilisateur.Role.AGENT
            self.utilisateur.save()
        super().save(*args, **kwargs)




class Specialite(models.Model):
    nom = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)

    def __str__(self):
        return self.nom

class Enseignant(BaseRoleModel):
    utilisateur = models.OneToOneField(
        Utilisateur,
        on_delete=models.CASCADE,
        primary_key=True,
        limit_choices_to={'role': 'ENSEIGNANT'}
    )
    specialites = models.ManyToManyField(Specialite, blank=True)
    autres_specialites = models.CharField(max_length=255, blank=True)

    def __str__(self):
        return f"{self.utilisateur}"

class Etudiant(BaseRoleModel):
    utilisateur = models.OneToOneField(
        Utilisateur,
        on_delete=models.CASCADE,
        primary_key=True,
        limit_choices_to={'role': 'ETUDIANT'}
    )

    def __str__(self):
        return f"{self.utilisateur.matricule} ‚Äì {self.utilisateur.last_name} {self.utilisateur.first_name} - {self.classe_actuelle}"
    def MNP(self):
        return f"{self.utilisateur.matricule} ‚Äì {self.utilisateur.last_name} {self.utilisateur.first_name}"

    @property
    def classe_actuelle(self):
        inscription = self.inscriptions.order_by('-annee_academique').first()
        return inscription.classe if inscription else None


class Parent(BaseRoleModel):
    utilisateur = models.OneToOneField(
        Utilisateur,
        on_delete=models.CASCADE,
        primary_key=True,
        limit_choices_to={'role': 'PARENT'}
    )
    enfants = models.ManyToManyField(Etudiant, related_name='parent')


class RolePermission(models.Model):
    print("\nInitialisation de RolePermission...")

    # Configuration temporaire des r√¥les
    ROLE_CHOICES = [
        ('ADMIN', 'Administrateur'),
        ('AGENT', 'Agent administratif'),
        ('ENSEIGNANT', 'Enseignant'),
        ('ETUDIANT', '√âtudiant'),
        ('PARENT', 'Parent')
    ]

    ROLE_PERMISSIONS_CONFIG = {
        'ADMIN': {
            '*': ['add', 'change', 'delete', 'view']
        },
        'AGENT': {
            'formation': ['add', 'change', 'view'],
            'classe': ['add', 'change', 'view'],
            'utilisateur': ['view']
        },
        'ENSEIGNANT': {
            'cours': ['add', 'change', 'delete', 'view'],
            'evaluation': ['view', 'change'],
            'emploidutemps': ['view']
        },
        'ETUDIANT': {
            'notes': ['view'],
            'emploidutemps': ['view']
        },
        'PARENT': {
            'notes': ['view']
        }
    }

    role = models.CharField(
        max_length=20,
        choices=ROLE_CHOICES,
        unique=True,
        verbose_name="R√¥le syst√®me"
    )
    permissions = models.ManyToManyField(Permission, blank=True)
    groupe = models.OneToOneField(Group, on_delete=models.CASCADE, null=True, blank=True)
    date_creation = models.DateTimeField(auto_now_add=True)
    date_maj = models.DateTimeField(auto_now=True)

    GROUP_NAMES = {
        'ADMIN': 'Groupe des administrateurs',
        'AGENT': 'Groupe des agents administratifs',
        'ENSEIGNANT': 'Groupe des enseignants',
        'ETUDIANT': 'Groupe des √©tudiants',
        'PARENT': 'Groupe des parents',
    }

    def __str__(self):
        return f"Permissions pour {self.get_role_display()}"

    def save(self, *args, **kwargs):
        print(f"\nD√©but save() RolePermission - r√¥le: {self.role}")

        if not self.groupe:
            print("Cr√©ation du groupe...")
            group_name = self.GROUP_NAMES.get(self.role, f"Groupe_{self.role}")
            groupe, created = Group.objects.get_or_create(name=group_name)
            self.groupe = groupe
            print(f"Groupe {'cr√©√©' if created else 'existant'}: {groupe.name}")

        super().save(*args, **kwargs)
        print("Mise √† jour des permissions...")
        self.update_permissions()
        print("RolePermission sauvegard√© avec succ√®s\n")

    def update_permissions(self):
        print(f"\nupdate_permissions() pour {self.role}")
        permissions = self._get_configured_permissions()
        print(f"Permissions √† appliquer ({len(permissions)}):")
        for p in permissions:
            print(f"- {p.codename}")

        if self.groupe:
            print(f"Mise √† jour du groupe {self.groupe.name}")
            self.groupe.permissions.set(permissions)

        print("Mise √† jour des permissions directes")
        self.permissions.set(permissions)

    @classmethod
    def init_permissions(cls):
        print("\nInitialisation globale des permissions par r√¥le...\n")
        for role, label in cls.ROLE_CHOICES:
            try:
                rp = cls.objects.get(role=role)
                print(f"‚úÖ RolePermission d√©j√† existant pour le r√¥le : {role}")
            except cls.DoesNotExist:
                print(f"üÜï Cr√©ation de RolePermission pour le r√¥le : {role}")
                rp = cls(role=role)
                rp.save()

            # ‚úÖ Mise √† jour forc√©e des permissions pour le groupe
            print(f"üîÑ Attribution des permissions au groupe pour le r√¥le : {role}")
            rp.update_permissions()

        print("\n‚úÖ Initialisation compl√®te des RolePermission termin√©e.\n")

    def _get_configured_permissions(self):
        print(f"\n_get_configured_permissions() pour {self.role}")
        permissions = []
        config = self.ROLE_PERMISSIONS_CONFIG.get(self.role, {})
        print(f"Configuration: {config}")

        for model, actions in config.items():
            if model == '*':
                print("Traitement des permissions globales (*)")
                perms = Permission.objects.filter(
                    codename__regex=r'^(%s)_[a-z]+' % '|'.join(actions)
                )
                print(f"Trouv√© {perms.count()} permissions globales")
                permissions.extend(perms)
            else:
                print(f"\nTraitement du mod√®le {model}")
                try:
                    ct = ContentType.objects.get(model=model)
                    print(f"ContentType trouv√©: {ct.app_label}.{ct.model}")

                    for action in actions:
                        perms = Permission.objects.filter(
                            content_type=ct,
                            codename__startswith=action
                        )
                        print(f"Permissions '{action}': {perms.count()} trouv√©es")
                        permissions.extend(perms)
                except ContentType.DoesNotExist:
                    print(f"ERREUR: ContentType inexistant pour {model}")
                    continue

        unique_perms = list(set(permissions))
        print(f"\nTotal permissions uniques: {len(unique_perms)}")
        return unique_perms
